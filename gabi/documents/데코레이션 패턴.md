# 3. 데코레이터 패턴

#### 정의

주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로, 객체에 추가적인 요건을 동적으로 첨가하며, 기능 확장이 필요할 때 서브클래싱 대신 쓸 수 있는 유연한 대안이 될 수 있다.(구성과 위임을 통해 실행중에 행동을 "상속" 시키는 방법)



> 그런데 이 책에서 궁금한거.. 
>
> 만약에 카페를 구현한다 했을때, 여러분들을 어떻게 구현을 할련지?



#### 디자인 원칙

클래스는 확장에 열려있고, 코드변경에 닫혀있어야 한다



<img src="/Users/gabi.def/Library/Application Support/typora-user-images/스크린샷 2021-05-14 오전 9.51.07.png" alt="스크린샷 2021-05-14 오전 9.51.07" style="zoom:50%;" />

#### 이 패턴의 동기

가끔 전체 클래스에 새로운 기능을 추가할 필요는 없지만, 개별적인 객체에 새로운 책임을 추가해주고 싶을때

(Ex) GUI 툴킷에서 모든 사용자가 인터페이스 요소에는 필요없지만, 어떤 사용자 인터페이스 요소에만 스크롤링과 같은 속성을 추가 할 수 있도록 해주고 싶을때

대부분 이렇게 새로운 서비스의 추가가 필요할때 이미 존재하는 클래스를 상속받고, 다른 클래스에서 테두리 속성을 상속받아 이 서브 클래스의 인스턴스에 테두리가 있도록 하지만, 유용하지 않다.(테두리 선택이 정적이라서..)



#### 언제 사용하는가?

- 객체의 타입과 호출 가능한 메소드를 그대로 유지하면서 객체에 새로운 책임을 추가할때

- 탈부착 가능한 책임을 정의할 때

- 상속을 통해 서브클래스를 계속 만드는 방법이 비효율적일때 --> 조합되는 경우의 수가 많으면 서브클래스 수가 폭발적으로 늘어나서..

   

#### 구현할때 고려해야될 점

- Component는 장식을 추가할 베이스가 되는 역할이므로 작고 가볍게 정의하도록 한다.
  - 가급적 인터페이스만을 정의한다.
  - 무언가 저장하는 변수는 정의하지 않는다(상속받는 여러 Decorator도 같이 복잡하고 무거워진다).
  - 저장할 것이 있다면 서브클래스에서 하자.
- 상속 구조를 통해 Decorator와 Component가 같은 인터페이스를 갖게 해야 한다.
  - 투과적 인터페이스: Decorator로 계속해서 감싸도 Component의 메소드는 계속 사용할 수 있다.
- 코드를 수정하지 않고도 준비된 Decorator을 조합해 기능을 추가할 수 있도록 생각해서 구현한다.
- 비슷한 성질의 작은 클래스가 많이 만들어질 수 있다는 단점을 고려한다.
- 구현하려는 내용이 객체의 겉을 변경하려는 것인지, 속을 변경하려는 것인지 생각해 보자.
  - 속을 변경하려는 것이라면 strategy-pattern을 선택하는 것이 더 적절할 수 있다.
- 데코레이터 패턴으로 구현한 다음, 사용이 까다롭게 느껴지거나 자주 쓰는 조합이 있다면 다음 패턴을 사용해 제공하는 것을 고려해 보자.
  - builder-pattern
  - factory-pattern
  - static-factory-method-pattern
- Decorator가 다른 Decorator에 대해 알아야 할 필요가 있다면, 데코레이터 패턴의 사용 의도와 어긋나는 작업일 수 있다.
- 재귀적으로 기능을 갖게 하는 방법 외에도, Decorator를 추가할 때마다 얻은 아이템을 List로 관리하는 방법도 있다.



#### 데코레이션 패턴의 또다른 예제 찾기

- 스마트폰과 스마트폰 케이스 :  (지갑(마그네틱(지지대(케이스))))

