# Decorator Pattern

---

## Decorator 패턴 이란?

객체에 특정 동작을 동적으로 추가할때 사용하는 패턴, ex) Logger, 가격 계산

```
햄버거 매장에서는 기본으로 제공되는 햄버거에 패티 추가, 소스 추가 등 여러 추가 옵션을 설정할 수 있습니다. 이 경우 햄버거 종류와 추가 옵션의 모든 조합을 클래스로 만들어 놓는다면 어마어마한 수의 클래스를
만들어야 하고, 그 중 햄버거 혹은 추가 옵션의 정보가 바뀌었을 때, 이를 수정하기도 만만치 않을 것 입니다.

쉬운 예제로 3개의 버거 종류 소고기 버거, 치킨 버거, 쉬림프 버거와 3개의 추가 옵션 패티 추가, 야채 추가, 소스 추가를 예로 들어보겠습니다. 위 버거와 추가 옵션의 모든 조합을 클래스로 만든다고 할 때, 각
버거별 가능한 추가 옵션의 조합은 3C3 + 3C2 + 3C1 해서 7개 조합이 나오며, 버거의 종류는 3가지 이므로 7 * 3 해서 만들어야 하는 클래스의 수는 21개 입니다. 만들고 관리할 수 있을만한 클래스
수로 보이나요? 그렇다면 햄버거 하나와 추가 옵션 하나씩 늘었을 경우를 보겠습니다. (4C4 + 4C3 + 4C2 + 4C1) * 4 해서 총 84개의 클래스를 만들어야 합니다. 이와 같이 모든 추가 옵션에 대한
조합을 클래스로 미리 만들어 놓는 것은 비효율적입니다.

```

[Link](https://luckydavekim.github.io/development/etc/head-first-design-patterns/decorator-pattern)

##                    

![](https://i.imgur.com/3f3NbCi.jpg?1)

- Component
    - 인터페이스의 역할
- ConcreteComponent
    - Component 의 구현체
- Decorator
    - Component 와 동일한 인터페이스를 가지며 구체적인 Decorator 의 Component
- ConcreteDecorator
    - Decorator 의 구현체

##               

![](https://i.imgur.com/1jUzaZy.png)

##             

![](https://i.imgur.com/ewLvO88.png)

##

![](https://i.imgur.com/ile62RJ.png)

## 장점

- 클라이언트입장에서는 데코레이터의 존재를 알 필요가 없다
- 객체에 추가 요소를 동적으로 더 할음 있음

## 단점

- 데코레이터는 그 데코레이터가 감싸고 있는 객체에 행동을 추가하기 위한 용도로 만들어졌기 때문에 여러 단계의 데코레이터 간에 작업이 필요할 경우 데코레이터 패턴과 어울리지 않는다
- 클래스가 많아진다.
- 구성요소 초기화가 필요하다